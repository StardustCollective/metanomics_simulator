import streamlit as st
import numpy as np
import pandas as pd
import plotly.express as px

# --- Disclaimer ---
st.markdown("""
**Disclaimer**: This simulation tool is provided for informational purposes only and does not constitute advice. 
The results generated by this tool are hypothetical and based on user inputs and predefined scenarios. They should not be considered as guarantees, 
predictions, or projections of future performance.
""")


# --- Parameters ---

# Predefined Parameters (no user input)
INITIAL_SUPPLY = 3693588685
I_INITIAL = 6.0 / 100
I_TARGET = 0.5 / 100
LAMBDA = 0.1
I_IMPACT = 0.350
DAG_DELEGATED_APR = 3.0 / 100 / 4
DELEGATOR_FEE = 7.5 / 100

# Scenario Presets
scenarios = {
    "Thriving Growth": {
        "description": "This scenario assumes a rapid metagraph adoption with the token price following and healthy cycle pattern",
        "base_price": 0.04,
        "P_INITIAL": 0.04,
        "CYCLE_YEARS": 4,
        "MIN_PRICE": 0.02,
        "MAX_PRICE": 1.0,
        "PRICE_VARIABILITY": 0.50,
        "DAG_DELEGATED_MIN": 0.35,
        "DAG_DELEGATED_MAX": 0.60,
        "initial_metagraphs": 5,
        "metagraph_growth_rate": 2,
        "use_custom_array": True,
        "custom_metagraph_array": "5,5,5,5,10,10,10,10,20,20,20,20,50,50,50,50,100,100,100,100,150,150,150,150,175,175,175,175,200,200,200,200,225,225,225,225,250,250,250,250,275,275,275,275,300,300,300,300"
    },
    "Conservative Growth": {
         "description": "This scenario assumes slow metagraph adoption with low token demand.",
        "base_price": 0.04,
        "P_INITIAL": 0.04,
        "CYCLE_YEARS": 4,
        "MIN_PRICE": 0.005,
        "MAX_PRICE": 0.1,
        "PRICE_VARIABILITY": 0.20,
        "DAG_DELEGATED_MIN": 0.35,
        "DAG_DELEGATED_MAX": 0.60,
        "initial_metagraphs": 5,
        "metagraph_growth_rate": 2,
        "use_custom_array": False,
        "custom_metagraph_array": ""
    },
    "Stable Growth": {
        "description": "This scenario assumes a steady increase in the number of metagraphs with minimal token price variability",
        "base_price": 0.04,
        "P_INITIAL": 0.04,
        "CYCLE_YEARS": 4,
        "MIN_PRICE": 0.03,
        "MAX_PRICE": 0.1,
        "PRICE_VARIABILITY": 0.10,
        "DAG_DELEGATED_MIN": 0.35,
        "DAG_DELEGATED_MAX": 0.60,
        "initial_metagraphs": 5,
        "metagraph_growth_rate": 5,
        "use_custom_array": False,
        "custom_metagraph_array": ""
    }
}

# User Inputs with labels
st.sidebar.header("Simulation Basis")
DURATION_YEARS = st.sidebar.number_input('Duration (Years): Total duration for the simulation in years.', value=15)
QUARTERS = DURATION_YEARS * 4
S_INITIAL = st.sidebar.number_input('Start Year: The starting year for the simulation.', value=2025)

st.sidebar.markdown("---")
st.sidebar.header("Scenario Presets")
scenario_selection = st.sidebar.selectbox("Select a Scenario:", list(scenarios.keys()))

selected_scenario = scenarios[scenario_selection]
st.sidebar.markdown(f"**Description**: {selected_scenario['description']}")


st.sidebar.header("Market conditions")
P_INITIAL = st.sidebar.number_input('Initial Price ($): Starting price of the token.', value=selected_scenario["P_INITIAL"])
CYCLE_YEARS = st.sidebar.number_input('Cycle Duration (Years): Duration of one price cycle in years.', value=selected_scenario["CYCLE_YEARS"])
MIN_PRICE = st.sidebar.number_input('Minimum Price ($): Minimum possible price for the token during the simulation.', value=selected_scenario["MIN_PRICE"])
MAX_PRICE = st.sidebar.number_input('Maximum Price ($): Maximum possible price for the token during the simulation.', value=selected_scenario["MAX_PRICE"])
PRICE_VARIABILITY = st.sidebar.number_input('Price Variability (%): Variability in token price during the cycles.', value=selected_scenario["PRICE_VARIABILITY"] * 100) / 100

st.sidebar.markdown("---")
st.sidebar.header("DAG Delegation")
DAG_DELEGATED_MIN = st.sidebar.number_input('Minimum DAG Delegated (%): Minimum percentage of DAG tokens delegated.', value=selected_scenario["DAG_DELEGATED_MIN"] * 100) / 100
DAG_DELEGATED_MAX = st.sidebar.number_input('Maximum DAG Delegated (%): Maximum percentage of DAG tokens delegated.', value=selected_scenario["DAG_DELEGATED_MAX"] * 100) / 100

is_correlation_dag_market = st.sidebar.checkbox('Correlate DAG Delegated with market conditions', value=False)

st.sidebar.markdown("---")
st.sidebar.header("Metagraphs")
METAGRAPH_BURN_RATE = st.sidebar.number_input('Quarterly Burn Rate: Number of tokens burned every quarter per Metagraph.', value=50000 * 3)

# Determine the default input method based on the selected scenario
if selected_scenario["use_custom_array"]:
    metagraph_input_method = "Input Custom Array"
else:
    metagraph_input_method = "Use Growth Rate"

metagraph_input_method = st.sidebar.radio("Metagraph Input Method", ("Use Growth Rate", "Input Custom Array"), index=0 if metagraph_input_method == "Use Growth Rate" else 1)

if metagraph_input_method == "Use Growth Rate":
    initial_metagraphs = st.sidebar.number_input('Initial Number of Metagraphs: Starting number of metagraphs.', value=selected_scenario["initial_metagraphs"])
    metagraph_growth_rate = st.sidebar.number_input('Yearly Growth Rate of Metagraphs: Annual growth rate of metagraphs.', value=selected_scenario["metagraph_growth_rate"])
    use_custom_array = False
else:
    custom_metagraph_array = st.sidebar.text_area('Metagraphs per quarter: Enter the number of metagraphs for each quarter, separated by commas.', value=selected_scenario["custom_metagraph_array"])
    custom_metagraph_array = [int(x.strip()) for x in custom_metagraph_array.split(",")]
    use_custom_array = True

st.sidebar.markdown("---")

# --- Functions ---

# Function to calculate quarterly inflation rate
def inflation_rate(quarter, current_price):
    Y = quarter / 4  # Convert quarter to year
    effective_price = max(current_price, MIN_PRICE)  # Ensure price is at least MIN_PRICE
    annual_inflation = I_TARGET + (I_INITIAL - I_TARGET) * np.exp(-LAMBDA * Y) * (P_INITIAL / effective_price) ** I_IMPACT
    return min(annual_inflation, I_INITIAL) / 4  # Convert annual inflation rate to quarterly

# Function to calculate quarterly supply based on inflation
def quarterly_supply(quarter, current_supply, current_price, metagraphs, dag_delegated_percentage):
    infl_rate = inflation_rate(quarter, current_price)
    new_tokens = current_supply * infl_rate  # Quarterly inflation rate
    apr_tokens = current_supply * dag_delegated_percentage * DAG_DELEGATED_APR  # Calculate APR on the DAG delegated
    total_new_tokens = new_tokens + apr_tokens
    burn_amount = METAGRAPH_BURN_RATE * metagraphs  # Amount of tokens burned by metagraphs
    net_new_tokens = total_new_tokens - burn_amount
    inflation_rate_with_delegated = total_new_tokens / current_supply  # Inflation rate including APR on delegated DAG
    real_inflation = net_new_tokens / current_supply  # Corrected real inflation calculation
    return current_supply + net_new_tokens, burn_amount, infl_rate * 4, apr_tokens, inflation_rate_with_delegated * 4, real_inflation * 4, net_new_tokens, total_new_tokens, new_tokens

# Function to generate prices with a custom pattern and small randomness
def generate_prices(quarters, initial_base_price):
    prices = np.zeros_like(quarters, dtype=float)
    base_price = initial_base_price
    cycle = 0

    # Set the initial price explicitly
    prices[0] = base_price

    for i, quarter in enumerate(quarters):
        if i == 0:
            continue  # Skip the first quarter since it's already set
        
        if (i % (CYCLE_YEARS * 4)) == 0:
            cycle += 1
            base_price = cycle * 0.05  # Adjusted example price increment per cycle
        
        cycle_progress = (i % (CYCLE_YEARS * 4)) / (CYCLE_YEARS * 4)
        trend_price = base_price + cycle_progress * (MAX_PRICE - base_price)
        
        random_factor = np.random.uniform(1 - PRICE_VARIABILITY, 1 + PRICE_VARIABILITY)
        current_price = trend_price * random_factor
        prices[i] = round(max(min(current_price, MAX_PRICE), MIN_PRICE), 3)  # Clamp the price within [MIN_PRICE, MAX_PRICE] and round to 3 decimals
    
    return prices

# Function to generate random DAG delegated percentage within the specified band
def generate_dag_delegated(quarters, prices, correlate):
    if not correlate:
        return np.random.uniform(DAG_DELEGATED_MIN, DAG_DELEGATED_MAX, size=len(quarters))
    else:
        min_price = min(prices)
        max_price = max(prices)
        normalized_prices = (prices - min_price) / (max_price - min_price)
        return DAG_DELEGATED_MIN + normalized_prices * (DAG_DELEGATED_MAX - DAG_DELEGATED_MIN)

# --- Tokenomics Model ---

def model_tokenomics(base_price):
    quarters = np.arange(0, QUARTERS)
    years = quarters / 4
    prices = generate_prices(quarters, base_price)
    dag_delegated = generate_dag_delegated(quarters, prices, is_correlation_dag_market)
    supplies = np.zeros(QUARTERS + 1)  # Adding one extra element for initial supply
    inflation_rates = np.zeros(QUARTERS)
    inflation_rates_with_delegated = np.zeros(QUARTERS)
    burn_amounts = np.zeros(QUARTERS)
    apr_tokens = np.zeros(QUARTERS)
    real_inflation_rates = np.zeros(QUARTERS)
    metagraph_counts = np.zeros(QUARTERS)
    new_tokens_millions = np.zeros(QUARTERS)
    total_dollars_emitted = np.zeros(QUARTERS)
    market_caps = np.zeros(QUARTERS)
    protocol_emissions = np.zeros(QUARTERS)
    validator_emissions = np.zeros(QUARTERS)
    delegator_emissions = np.zeros(QUARTERS)
    foundation_emissions = np.zeros(QUARTERS)
    fixed_delegator_emissions = np.zeros(QUARTERS)
    total_emissions = np.zeros(QUARTERS)
    protocol_emissions_pct = np.zeros(QUARTERS)
    validator_emissions_pct = np.zeros(QUARTERS)
    delegator_emissions_pct = np.zeros(QUARTERS)
    foundation_emissions_pct = np.zeros(QUARTERS)

    if use_custom_array:
        metagraph_sequence = custom_metagraph_array
    else:
        metagraphs = initial_metagraphs

    current_supply = INITIAL_SUPPLY
    supplies[0] = current_supply  # Initial supply at the start
    dag_delegated_amounts = np.zeros(QUARTERS)  # Array to store the amount of DAG delegated
    for i, quarter in enumerate(quarters):
        if use_custom_array:
            if i < len(metagraph_sequence):
                metagraphs = metagraph_sequence[i]
            else:
                metagraphs = metagraph_sequence[-1]  # Use the last value if quarters exceed array length
        else:
            if i % 4 == 0:
                metagraphs += metagraph_growth_rate  # Fixed number added each quarter

        current_price = prices[i]
        current_dag_delegated_percentage = dag_delegated[i]
        supplies[i + 1], burn_amounts[i], inflation_rates[i], apr_tokens[i], inflation_rates_with_delegated[i], real_inflation_rates[i], net_new_tokens, total_new_tokens, new_tokens = quarterly_supply(quarter, current_supply, current_price, metagraphs, current_dag_delegated_percentage)

        # Calculate fixed delegator emissions based on the supply at the beginning of the quarter
        fixed_delegator_emissions[i] = current_supply * current_dag_delegated_percentage * DAG_DELEGATED_APR

        current_supply = supplies[i + 1]
        metagraph_counts[i] = metagraphs
        new_tokens_millions[i] = total_new_tokens / 1e6  # Convert to millions
        total_dollars_emitted[i] = total_new_tokens * current_price  # Total dollars emitted
        market_caps[i] = current_supply * current_price  # Market cap
        dag_delegated_amounts[i] = current_supply * current_dag_delegated_percentage  # Amount of DAG delegated

        # Calculate quarterly ramp-up for protocol emissions
        if quarter < 5:
            protocol_emissions_pct[i] = quarter * 6  # Ramp-up by 6% each quarter
        else:
            protocol_emissions_pct[i] = 30  # Cap at 30%

        # Calculate ramp down for foundation emissions
        if quarter < 5:
            foundation_pct = 35 - quarter * 6  # Ramp down by 6% each quarter
        else:
            foundation_pct = 5  # Cap at 5%

        foundation_emissions_pct[i] = foundation_pct

        # Calculate emissions based on new tokens from inflation only
        protocol_emissions[i] = new_tokens * (protocol_emissions_pct[i] / 100)
        foundation_emissions[i] = new_tokens * (foundation_emissions_pct[i] / 100)
        validator_emissions[i] = new_tokens * 0.20
        delegator_emissions[i] = new_tokens * 0.45

        # Adjust delegator emissions for the 7.5% fee
        delegator_emissions_fee = delegator_emissions[i] * DELEGATOR_FEE
        validator_emissions[i] += delegator_emissions_fee  # Add the fee to validator emissions
        delegator_emissions[i] -= delegator_emissions_fee  # Subtract the fee from delegator emissions

        total_emissions[i] = protocol_emissions[i] + foundation_emissions[i] + validator_emissions[i] + delegator_emissions[i] + fixed_delegator_emissions[i]

        protocol_emissions_pct[i] = (protocol_emissions[i] / total_emissions[i]) * 100
        foundation_emissions_pct[i] = (foundation_emissions[i] / total_emissions[i]) * 100
        validator_emissions_pct[i] = (validator_emissions[i] / total_emissions[i]) * 100
        delegator_emissions_pct[i] = ((delegator_emissions[i] + fixed_delegator_emissions[i]) / total_emissions[i]) * 100

    # Create a DataFrame for visualization
    data = pd.DataFrame({
        'Year': S_INITIAL + (quarters / 4),
        'Supply (billions)': supplies[:-1] / 1e9,  # Use supplies[:-1] to match quarters length, Convert supply to billions
        'Price ($)': prices,
        'Inflation Rate (%)': inflation_rates * 100,  # Keep as annual inflation rate
        'DAG Delegated (%)': dag_delegated * 100,
        'DAG Delegated (billions)': dag_delegated_amounts / 1e9,  # Convert DAG delegated to billions
        'Inflation Rate with Delegated (%)': inflation_rates_with_delegated * 100,  # Keep as annual inflation rate
        'Metagraphs': metagraph_counts,
        'Real Inflation Rate after Burn (%)': real_inflation_rates * 100,  # Keep as annual inflation rate
        'New Tokens Added (millions)': new_tokens_millions,
        'Total Dollars Emitted (Million $)': total_dollars_emitted / 1e6,
        'Market Cap (Million $)': market_caps / 1e6  # Convert market cap to Millions
    })

    emissions_data = pd.DataFrame({
        'Year': S_INITIAL + (quarters / 4),
        'Protocol (%)': protocol_emissions_pct.round(1),
        'Protocol Emissions': protocol_emissions,
        'Foundation (%)': foundation_emissions_pct.round(1),
        'Foundation Emissions': foundation_emissions,
        'Validator (%)': validator_emissions_pct.round(1),
        'Validator Emissions': validator_emissions,
        'Delegator (fixed + variable) (%)': delegator_emissions_pct.round(1),
        'Variable Delegator Emissions': delegator_emissions,
        'Fixed Delegator Emissions': fixed_delegator_emissions
    })

    return data, emissions_data

data, emissions_data = model_tokenomics(selected_scenario["base_price"])

# Streamlit app
st.title('Tokenomics Model')

# Token Supply
fig_supply = px.line(data, x='Year', y=['Supply (billions)', 'DAG Delegated (billions)'], title='Token Supply and DAG Delegated Over Time')
fig_supply.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[0, 1.3 * max(data['Supply (billions)'].max(), data['DAG Delegated (billions)'].max())]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_supply)

# Token Price
fig_price = px.line(data, x='Year', y='Price ($)', title='Token Price Over Time')
fig_price.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[0, 1.3 * data['Price ($)'].max()]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_price)

# Inflation Rates
fig_inflation = px.line(data, x='Year', y=['Inflation Rate (%)', 'Inflation Rate with Delegated (%)', 'Real Inflation Rate after Burn (%)'], title='Inflation Rates Over Time')
fig_inflation.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[-3, 1.5 * max(data['Inflation Rate (%)'].max(), data['Inflation Rate with Delegated (%)'].max(), data['Real Inflation Rate after Burn (%)'].max())]))  # Ensure all years are displayed and y-axis starts from -10%
st.plotly_chart(fig_inflation)

# DAG Delegated
fig_dag_delegated = px.line(data, x='Year', y='DAG Delegated (%)', title='DAG Delegated Over Time')
fig_dag_delegated.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[0,100]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_dag_delegated)

# New Tokens Added
fig_new_tokens = px.line(data, x='Year', y='New Tokens Added (millions)', title='New Tokens Added Over Time')
fig_new_tokens.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[0, 1.1 * data['New Tokens Added (millions)'].max()]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_new_tokens)

# Market Cap
fig_market_cap = px.line(data, x='Year', y='Market Cap (Million $)', title='Market Cap Over Time')
fig_market_cap.update_layout(xaxis=dict(tickmode='linear', tick0=data['Year'].min(), dtick=1), yaxis=dict(range=[0, 1.1 * data['Market Cap (Million $)'].max()]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_market_cap)

# Emissions Data
fig_emissions = px.line(emissions_data, x='Year', y=['Protocol (%)', 'Foundation (%)', 'Validator (%)', 'Delegator (fixed + variable) (%)'], title='Emissions Split Over Time')
fig_emissions.update_layout(xaxis=dict(tickmode='linear', tick0=emissions_data['Year'].min(), dtick=1), yaxis=dict(range=[0, 1.3 * max(emissions_data['Protocol (%)'].max(), emissions_data['Foundation (%)'].max(), emissions_data['Validator (%)'].max(), emissions_data['Delegator (fixed + variable) (%)'].max())]))  # Ensure all years are displayed and y-axis starts from zero
st.plotly_chart(fig_emissions)

# Display the data
st.dataframe(data)

# Display the emissions data
st.title('Emissions Data')
st.dataframe(emissions_data)
